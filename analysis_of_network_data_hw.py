# -*- coding: utf-8 -*-
"""Analysis of network data HW.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oSx2TjnzL7XTZgpvYRfbv71176j0_Gqs
"""

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import random
from scipy.sparse import eye
from scipy.sparse.linalg import eigsh, spsolve


X = 7
Y = 3
N = 106
N1 = int(round(N * X / (X + Y)))
N2 = N - N1


k_avg_target = X * Y
ratio = 1.0 / (10.0 + X * Y)


denom = ((N1*(N1-1) + N2*(N2-1))/N) + (ratio * (2*N1*N2)/N)


p1 = k_avg_target / denom
p2 = p1 * ratio

#probabilities within [0, 1]
p1 = min(1.0, max(0.0, p1))
p2 = min(1.0, max(0.0, p2))

# Build the graph
G = nx.Graph()
G.add_nodes_from(range(N))


labels_primary = np.zeros(N)
labels_primary[N1:] = 1

# Add edges
for i in range(N):
    for j in range(i + 1, N):
        p = p1 if labels_primary[i] == labels_primary[j] else p2
        if random.random() < p:
            G.add_edge(i, j)


actual_avg_degree = sum(dict(G.degree()).values()) / N
print(f"Target k: {k_avg_target}, Actual k: {actual_avg_degree:.2f}")

#Coarsening

mis = nx.maximal_independent_set(G)
node_to_coarse = {}

# Map each fine node to a coarse representative
for v in G.nodes():
    if v in mis: node_to_coarse[v] = v
    else:
        neighbors = [n for n in G.neighbors(v) if n in mis]
        node_to_coarse[v] = neighbors[0] if neighbors else mis[0]


G_coarse = nx.Graph()
for u, v in G.edges():
    cu, cv = node_to_coarse[u], node_to_coarse[v]
    if cu != cv: G_coarse.add_edge(cu, cv)


labels_coarse_primary = []
coarse_nodes = list(G_coarse.nodes())
for cn in coarse_nodes:
    # Collect all original (fine) nodes that were mapped to this coarse node
    fine_nodes = [fn for fn, c in node_to_coarse.items() if c == cn]
    votes = labels_primary[fine_nodes]
    labels_coarse_primary.append(1 if np.mean(votes) > 0.5 else 0)

#RQI
def run_rqi(graph, iters=5):
    # Laplacian matrix of the graph
    L = nx.laplacian_matrix(graph).astype(float)
    n_c = graph.number_of_nodes()


    vals, vecs = eigsh(L, k=2, which='SM')
    v = vecs[:, 1]

    for _ in range(iters):
        # Rayleigh Quotient mu = (v^T L v) / (v^T v)
        mu = np.dot(v.T, L @ v) / np.dot(v.T, v)

        # Solve shifted system: (L - mu*I) * w = v
        try:
            shift_L = L - mu * eye(n_c)
            w = spsolve(shift_L, v)
            v = w / np.linalg.norm(w)  # Normalize
        except:
            break  # Break if the shifted matrix becomes singular or solve fails
    return v


fiedler_refined = run_rqi(G_coarse)
labels_coarse_res = (fiedler_refined > np.median(fiedler_refined)).astype(int)

#Quantitative comparison + conclusion ---
def get_acc(pred, true):
    # Since cluster labels may be flipped, take the best alignment
    a = np.mean(pred == true)
    return max(a, 1-a)

# Lift coarse labels back to fine level (each fine node inherits its coarse representative label)
acc_fine = get_acc(np.array([labels_coarse_res[coarse_nodes.index(node_to_coarse[i])] for i in range(N)]), labels_primary)

# Accuracy on the coarse graph itself against coarse ground-truth labels
acc_coarse = get_acc(labels_coarse_res, np.array(labels_coarse_primary))

print(f"Quantitative Comparison:\n- Coarse Graph Acc: {acc_coarse:.2%}\n- Fine Graph Acc: {acc_fine:.2%}")


# Visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
pos = nx.spring_layout(G_coarse, seed=42)

nx.draw(G_coarse, pos, node_color=labels_coarse_primary, ax=ax1, with_labels=True, cmap='coolwarm')
ax1.set_title("Coarsened: Primary (Ground Truth)")

nx.draw(G_coarse, pos, node_color=labels_coarse_res, ax=ax2, with_labels=True, cmap='coolwarm')
ax2.set_title("Coarsened: Resulting (After RQI)")

plt.show()